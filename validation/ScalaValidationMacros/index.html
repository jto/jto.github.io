

<html>
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
        <title>ScalaValidationMacros</title>
        <link rel="stylesheet" media="screen" href="../resources/style/main.css"></link>
        <script type="text/javascript" src='../resources/webjars/2.3.0-RC1/jquery/jquery.min.js'></script>
        <script type="text/javascript" src="../resources/style/main.js"></script>
    </head>
    <body>

        <section id="top">
            <div class="wrapper">
                <h1><a href="../index.html">Manual, tutorials & references</a></h1>
                <nav>
                    <span class="versions">
                        <span>Browse APIs</span>
                        <select onchange="document.location=this.value">
                            <option selected disabled>Select language</option>
                            <option value="/@documentation/api/scala/index.html">Scala</option>
                            <option value="/@documentation/api/java/index.html">Java</option>
                        </select>
                    </span>
                </nav>
            </div>
        </section>

        <div id="content" class="wrapper doc">
            <article id="main">
                
                    <h1>Validation Inception</h1>
<blockquote><p>This feature is experimental such as Scala Macros which are flagged experimental in Scala 2.10.0.<br/>If you would rather not use Scala experimental features, just stick to hand-written <code>Rule</code> / <code>Write</code> which are strictly equivalent.</p>
</blockquote><h2>Introduction</h2><p>The validation API provides macro-based helpers to generate <code>Rule</code> and <code>Write</code> for case classes (or any class with a companion object providing <code>apply</code> / and <code>unapply</code> methods).</p><p>The generated code:</p>
<ul>
  <li>is completely typesafe</li>
  <li>is compiled</li>
  <li>does not rely on runtime introspection <strong>at all</strong></li>
  <li>is strictly equivalent to a hand-written definition</li>
</ul><h2>Example</h2><p>Traditionally, for a given case class <code>Person</code> we would define a <code>Rule</code> like this:</p>
<pre class="prettyprint"><code class="language-scala">case class Person(name: String, age: Int, lovesChocolate: Boolean)</code></pre>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json._
import play.api.data.mapping._

implicit val personRule = From[JsValue] { __ =&gt;
  import play.api.data.mapping.json.Rules._
  ((__ \ &quot;name&quot;).read[String] and
   (__ \ &quot;age&quot;).read[Int] and
   (__ \ &quot;lovesChocolate&quot;).read[Boolean])(Person.apply _)
}</code></pre><p>Let&rsquo;s test it:</p>
<pre class="prettyprint"><code class="language-scala">val json = Json.parse(&quot;&quot;&quot;{
  &quot;name&quot;: &quot;Julien&quot;,
  &quot;age&quot;: 28,
  &quot;lovesChocolate&quot;: true
}&quot;&quot;&quot;)

personRule.validate(json) == Success(Person(&quot;Julien&quot;,28,true))</code></pre><p>The exact same <code>Rule</code> can be generated using <code>Rule.gen</code>:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json._
import play.api.data.mapping._

implicit val personRule = {
  import play.api.data.mapping.json.Rules._ // let&#39;s no leak implicits everywhere
  Rule.gen[JsValue, Person]
}</code></pre><p>The validation result is identical :</p>
<pre class="prettyprint"><code class="language-scala">val json = Json.parse(&quot;&quot;&quot;{
  &quot;name&quot;: &quot;Julien&quot;,
  &quot;age&quot;: 28,
  &quot;lovesChocolate&quot;: true
}&quot;&quot;&quot;)

personRule.validate(json) == Success(Person(&quot;Julien&quot;,28,true))</code></pre><p>Similarly we can generate a <code>Write</code>:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json._
import play.api.data.mapping._

implicit val personWrite = {
  import play.api.data.mapping.json.Writes._ // let&#39;s no leak implicits everywhere
  Write.gen[Person, JsObject]
}

personWrite.writes(Person(&quot;Julien&quot;, 28, true)) === Json.parse(&quot;&quot;&quot;{&quot;name&quot;:&quot;Julien&quot;,&quot;age&quot;:28,&quot;lovesChocolate&quot;:true}&quot;&quot;&quot;)</code></pre><h2>Known limitations</h2>
<ul>
  <li><strong>Donâ€™t override the apply method of the companion object.</strong> The macro inspects the <code>apply</code> method to generate <code>Rule</code>/<code>Write</code>. Overloading the <code>apply</code> method creates an ambiguity the compiler will complain about.</li>
  <li><strong>Macros only work when <code>apply</code> and <code>unapply</code> have corresponding input/output types</strong>. This is naturally true for case classes. However if you want to validate a trait, you must implement the same <code>apply</code>/<code>unapply</code> you would have in a case class.</li>
  <li><strong>Validation Macros accept <code>Option</code>/<code>Seq</code>/<code>List</code>/<code>Set</code> &amp; <code>Map[String, _]</code></strong>. For other generic types, you&rsquo;ll have to test and possibly write your <code>Rule</code>/<code>Write</code> if it&rsquo;s not working out of the box.</li>
</ul>
<blockquote><p><strong>Next:</strong> - <a href=" ../ScalaValidationExtensions/index.html">Supporting new types </a></p>
</blockquote>
                
            </article>
            <aside>
                <h3>Play data validation API</h3>
<ul>
  <li><a href=" ../ScalaValidation/index.html">Introduction </a></li>
  <li><a href=" ../ScalaValidationRule/index.html">Validation and transformation with Rule </a></li>
  <li><a href=" ../ScalaValidationRuleCombinators/index.html">Complex validation: combining Rules </a></li>
  <li><a href=" ../ScalaValidationWrite/index.html">Serialization with Write </a></li>
  <li><a href=" ../ScalaValidationWriteCombinators/index.html">Complex serialization: combining Writes </a></li>
  <li><a href=" ../ScalaValidationForm/index.html">Forms template helpers </a></li>
  <li><a href=" index.html">Validation Inception </a></li>
  <li><a href=" ../ScalaValidationExtensions/index.html">Supporting new types </a></li>
  <li><a href=" ../ScalaValidationMigrationJson/index.html">Migration from 2.1.x Json API </a></li>
  <li><a href=" ../ScalaValidationMigrationForm/index.html">Migration from 2.1.x Form API </a></li>
  <li><a href=" ../ScalaValidationCookbook/index.html">Cookbook </a></li>
</ul><h3>Main concepts</h3>
<ul>
  <li><a href=" ../ScalaActions/index.html">HTTP programming </a></li>
  <li><a href=" ../ScalaAsync/index.html">Asynchronous HTTP programming </a></li>
  <li><a href=" ../ScalaTemplates/index.html">The template engine </a></li>
  <li><a href=" ../ScalaForms/index.html">HTTP form submission and validation </a></li>
  <li><a href=" ../ScalaJson/index.html">Working with JSON </a></li>
  <li><a href=" ../ScalaXmlRequests/index.html">Working with XML </a></li>
  <li><a href=" ../ScalaFileUpload/index.html">Handling file upload </a></li>
  <li><a href=" ../ScalaDatabase/index.html">Accessing an SQL database </a></li>
  <li><a href=" ../ScalaCache/index.html">Using the Cache </a></li>
  <li><a href=" ../ScalaWS/index.html">Calling WebServices </a></li>
  <li><a href=" ../ScalaAkka/index.html">Integrating with Akka </a></li>
  <li><a href=" ../ScalaI18N/index.html">Internationalization </a></li>
  <li><a href=" ../ScalaGlobal/index.html">The application Global object </a></li>
  <li><a href=" ../ScalaTest/index.html">Testing your application </a></li>
</ul><h3>Advanced topics</h3>
<ul>
  <li><a href=" ../Iteratees/index.html">Handling data streams reactively </a></li>
</ul><h3>Tutorials</h3>
<ul>
  <li><a href=" ../ScalaTodoList/index.html">Your first application </a></li>
</ul>
            </aside>
        </div>

        <style type="text/css">
            @import '../resources/webjars/2.3.0-RC1/prettify/prettify.css';
        </style>
        <script type="text/javascript" charset="utf-8" src='../resources/webjars/2.3.0-RC1/prettify/prettify.js'></script>
        <script type="text/javascript" charset="utf-8" src='../resources/webjars/2.3.0-RC1/prettify/lang-scala.js'></script>
        <script type="text/javascript">
            $(function() {
                window.prettyPrint && prettyPrint();
            });
        </script>

    </body>
</html>

<!-- Localized -->