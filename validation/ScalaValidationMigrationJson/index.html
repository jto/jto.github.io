

<html>
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
        <title>ScalaValidationMigrationJson</title>
        <link rel="stylesheet" media="screen" href="../resources/style/main.css"></link>
        <script type="text/javascript" src='../resources/webjars/2.3.0-RC1/jquery/jquery.min.js'></script>
        <script type="text/javascript" src="../resources/style/main.js"></script>
    </head>
    <body>

        <section id="top">
            <div class="wrapper">
                <h1><a href="../index.html">Manual, tutorials & references</a></h1>
                <nav>
                    <span class="versions">
                        <span>Browse APIs</span>
                        <select onchange="document.location=this.value">
                            <option selected disabled>Select language</option>
                            <option value="/@documentation/api/scala/index.html">Scala</option>
                            <option value="/@documentation/api/java/index.html">Java</option>
                        </select>
                    </span>
                </nav>
            </div>
        </section>

        <div id="content" class="wrapper doc">
            <article id="main">
                
                    <h1>Migration from the Json API</h1><p>The Json API and the new validation API are really similar. One could see the new Validation API as just an evolution of the Json API.</p>
<blockquote><p>The json validation API <strong>still works just fine</strong> but we recommend you use the new validation API for new code, and to port your old code whenever it&rsquo;s possible.</p>
</blockquote><h2><code>Reads</code> migration</h2><p>The equivalent of a Json <code>Reads</code> is a <code>Rule</code>. The key difference is that <code>Reads</code> assumes Json input, while <code>Rule</code> is more generic, and therefore has one more type parameter.</p><p>Basically <code>Reads[String]</code> == <code>Rule[JsValue, String]</code>.</p><p>Migrating a Json <code>Reads</code> to a <code>Rule</code> is just a matter of modifying imports and specifying the input type.</p><p>Let&rsquo;s take a typical example from the Json API documentation:</p>
<pre class="prettyprint"><code class="language-scala">case class Creature(
  name: String,
  isDead: Boolean,
  weight: Float)</code></pre><p>Using the json API, you would have defined something like:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json._
import play.api.libs.functional.syntax._

implicit val creatureReads = (
  (__ \ &quot;name&quot;).read[String] ~
  (__ \ &quot;isDead&quot;).read[Boolean] ~
  (__ \ &quot;weight&quot;).read[Float]
)(Creature.apply _)

val js = Json.obj( &quot;name&quot; -&gt; &quot;gremlins&quot;, &quot;isDead&quot; -&gt; false, &quot;weight&quot; -&gt; 1.0F)
Json.fromJson[Creature](js) === JsSuccess(Creature(&quot;gremlins&quot;,false,1.0F))</code></pre><p>Using the new API, this code becomes:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json._
import play.api.data.mapping._

implicit val creatureRule = From[JsValue]{ __ =&gt;
  import play.api.data.mapping.json.Rules._
  (
    (__ \ &quot;name&quot;).read[String] ~
    (__ \ &quot;isDead&quot;).read[Boolean] ~
    (__ \ &quot;weight&quot;).read[Float]
  )(Creature.apply _)
}

val js = Json.obj( &quot;name&quot; -&gt; &quot;gremlins&quot;, &quot;isDead&quot; -&gt; false, &quot;weight&quot; -&gt; 1.0F)
From[JsValue, Creature](js) === Success(Creature(&quot;gremlins&quot;,false,1.0F))</code></pre><p>Which appart from the extra imports is very similar. Notice the <code>From[JsValue]{...}</code> block, that&rsquo;s one of the nice features of the new validation API. Not only it avoids type repetition, but it also scopes the implicits.</p>
<blockquote><p><strong>Important:</strong> Note that we&rsquo;re importing <code>Rules._</code> <strong>inside</strong> the <code>From[JsValue]{...}</code> block.<br/>It is recommended to always follow this pattern, as it nicely scopes the implicits, avoiding conflicts and accidental shadowing.</p>
</blockquote><h3>readNullable</h3><p>The readNullable method does not exists anymore. Just use a <code>Rule[JsValue, Option[T]]</code> instead. <code>null</code> and non existing Path will be handled correctly and give you a <code>None</code>:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json._
import play.api.data.mapping._

val nullableStringRule = From[JsValue]{ __ =&gt;
  import play.api.data.mapping.json.Rules._
  (__ \ &quot;foo&quot;).read[Option[String]]
}

val js1 = Json.obj(&quot;foo&quot; -&gt; &quot;bar&quot;)
val js2 = Json.obj(&quot;foo&quot; -&gt; JsNull)
val js3 = Json.obj()

nullableStringRule.validate(js1) === Success(Some(&quot;bar&quot;))
nullableStringRule.validate(js2) === Success(None)
nullableStringRule.validate(js3) === Success(None)</code></pre><h3>keepAnd</h3><p>The general use for <code>keepAnd</code> is to apply two validation on the same <code>JsValue</code>, for example:</p>
<pre class="prettyprint"><code class="language-scala">(JsPath \ &quot;key1&quot;).read[String](email keepAnd minLength[String](5))</code></pre><p>You can achieve the same think in the Validation API using <a href="../ScalaValidationRule/index.html">Rules composition</a></p>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json._
import play.api.data.mapping._

From[JsValue]{ __ =&gt;
  import play.api.data.mapping.json.Rules._
  (__ \ &quot;key1&quot;).read(email |+| minLength(5))
}</code></pre><h3>lazy reads</h3><p>Reads are always lazy in the new validation API, therefore you don&rsquo;t need to use any specific function, even for recursive types:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json._
import play.api.libs.functional.syntax._

case class User(id: Long, name: String, friend: Option[User] = None)

implicit lazy val UserReads: Reads[User] = (
  (__ \ &#39;id).read[Long] and
  (__ \ &#39;name).read[String] and
  (__ \ &#39;friend).lazyReadNullable(UserReads)
)(User.apply _)

val js = Json.obj(
  &quot;id&quot; -&gt; 123L,
  &quot;name&quot; -&gt; &quot;bob&quot;,
  &quot;friend&quot; -&gt; Json.obj(&quot;id&quot; -&gt; 124L, &quot;name&quot; -&gt; &quot;john&quot;, &quot;friend&quot; -&gt; JsNull))

Json.fromJson[User](js) === JsSuccess(User(123L, &quot;bob&quot;, Some(User(124L, &quot;john&quot;, None))))</code></pre><p>becomes:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json._
import play.api.data.mapping._

case class User(id: Long, name: String, friend: Option[User] = None)

implicit lazy val userRule: Rule[JsValue, User] = From[JsValue]{ __ =&gt;
  import play.api.data.mapping.json.Rules._
  (
    (__ \ &quot;id&quot;).read[Long] and
    (__ \ &quot;name&quot;).read[String] and
    (__ \ &quot;friend&quot;).read(option(userRule))
  )(User.apply _)
}

val js = Json.obj(
  &quot;id&quot; -&gt; 123L,
  &quot;name&quot; -&gt; &quot;bob&quot;,
  &quot;friend&quot; -&gt; Json.obj(&quot;id&quot; -&gt; 124L, &quot;name&quot; -&gt; &quot;john&quot;, &quot;friend&quot; -&gt; JsNull))

From[JsValue, User](js) === Success(User(123L, &quot;bob&quot;, Some(User(124L, &quot;john&quot;, None))))</code></pre><h3>Numeric types</h3><p>You should be aware that numeric type coercion is a bit stricter in the validation API.</p><p>For example:</p>
<pre class="prettyprint"><code class="language-scala">val js = Json.obj(&quot;n&quot; -&gt; 42.5f)
js.validate((__ \ &quot;n&quot;).read[Int]) // JsSuccess(42, /n)
</code></pre><p>whereas with the validation API, an <code>Int</code> must really be an <code>Int</code>:</p>
<pre class="prettyprint"><code class="language-scala">val js = Json.obj(&quot;n&quot; -&gt; 42.5f)
(Path \ &quot;n&quot;).read[JsValue, Int].validate(js) // Failure(List((/n,List(ValidationError(validation.type-mismatch,WrappedArray(Int))))))
</code></pre><h3><code>json.apply</code> and <code>path.as[T]</code></h3><p>Those methods do not exist in the validation API. Even in the json API, it is generally recommended not to use them as they are &ldquo;unsafe&rdquo;.</p><p>The preferred solution is to use <code>path.read[T]</code> and to handle failure properly.</p>
<pre class="prettyprint"><code class="language-scala">(__ \ &quot;foo&quot;).as[String]
</code></pre><p>becomes</p>
<pre class="prettyprint"><code class="language-scala">(Path \ &quot;foo&quot;).read[JsValue, String]
</code></pre><h3>pickBranch</h3><p><code>JsPath</code> has a <code>prickBranch</code> method, that creates a <code>Reads</code> extracting a subtree in a Json object:</p><p>For example, given the following json object, we can extract a sub tree:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json._

val js = Json.obj(
	&quot;field1&quot; -&gt; &quot;alpha&quot;,
	&quot;field2&quot; -&gt; 123L,
	&quot;field3&quot; -&gt; Json.obj(
	  &quot;field31&quot; -&gt; &quot;beta&quot;,
	  &quot;field32&quot;-&gt; 345
	))

val pick = (__ \ &quot;field3&quot;).json.pickBranch
pick.reads(js) // Success({&quot;field3&quot;:{&quot;field31&quot;:&quot;beta&quot;,&quot;field32&quot;:345}})
</code></pre><p>In the validation API, you simply use <code>read</code> to create a rule picking a branch:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json._
import play.api.data.mapping._

val js = Json.obj(
	&quot;field1&quot; -&gt; &quot;alpha&quot;,
	&quot;field2&quot; -&gt; 123L,
	&quot;field3&quot; -&gt; Json.obj(
	  &quot;field31&quot; -&gt; &quot;beta&quot;,
	  &quot;field32&quot;-&gt; 345
	))

val pick = From[JsValue]{ __ =&gt;
	import play.api.data.mapping.json.Rules._
	(__ \ &quot;field3&quot;).read[JsValue]
}

pick.validate(js) // Success({&quot;field31&quot;:&quot;beta&quot;,&quot;field32&quot;:345})
</code></pre><h2><code>Writes</code> migration</h2><p><code>Writes</code> are really easy to port. Just like <code>Reads</code>, it&rsquo;s basically a matter of adding imports.</p><p>For example, you would have defined a <code>Writes</code> for the <code>Creature</code> case class this way:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json._
import play.api.libs.functional.syntax._

case class Creature(
  name: String,
  isDead: Boolean,
  weight: Float)

implicit val creatureWrite =
	(
	  (__ \ &quot;name&quot;).write[String] ~
	  (__ \ &quot;isDead&quot;).write[Boolean] ~
	  (__ \ &quot;weight&quot;).write[Float]
	)(unlift(Creature.unapply _))

val c = Json.toJson(Creature(&quot;gremlins&quot;, false, 1f)) // c: JsValue = {&quot;name&quot;:&quot;gremlins&quot;,&quot;isDead&quot;:false,&quot;weight&quot;:1.0}
</code></pre><p>With the validation API:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json._
import play.api.data.mapping._
import play.api.libs.functional.syntax.unlift

case class Creature(
  name: String,
  isDead: Boolean,
  weight: Float)

implicit val creatureWrite = To[JsObject]{ __ =&gt;
	import play.api.data.mapping.json.Writes._
	(
	  (__ \ &quot;name&quot;).write[String] ~
	  (__ \ &quot;isDead&quot;).write[Boolean] ~
	  (__ \ &quot;weight&quot;).write[Float]
	)(unlift(Creature.unapply _))
}

val c = To[Creature, JsObject](Creature(&quot;gremlins&quot;, false, 1f)) // c: JsObject = {&quot;name&quot;:&quot;gremlins&quot;,&quot;isDead&quot;:false,&quot;weight&quot;:1.0}
</code></pre><h2><code>Format</code> migration</h2><p>The validation API does not have an equivalent for <code>Format</code>. We find that generally <code>Format</code> is not really convenient since validation and serialization are rarely symmetrical, and you quite often end up havind multiple <code>Reads</code> for a given type, making <code>Format</code> rather unsettling.</p><h2>Json Inception (macro)</h2><p>Macros are also available for the validation API. See <a href="../ScalaValidationMacros/index.html">Validation Inception</a>.</p>
<blockquote><p><strong>Next:</strong> - <a href="../ScalaValidationMigrationForm/index.html">Migration from 2.1.x Form API</a></p>
</blockquote>
                
            </article>
            <aside>
                <h3>Play data validation API</h3>
<ul>
  <li><a href=" ../ScalaValidation/index.html">Introduction </a></li>
  <li><a href=" ../ScalaValidationRule/index.html">Validation and transformation with Rule </a></li>
  <li><a href=" ../ScalaValidationRuleCombinators/index.html">Complex validation: combining Rules </a></li>
  <li><a href=" ../ScalaValidationWrite/index.html">Serialization with Write </a></li>
  <li><a href=" ../ScalaValidationWriteCombinators/index.html">Complex serialization: combining Writes </a></li>
  <li><a href=" ../ScalaValidationForm/index.html">Forms template helpers </a></li>
  <li><a href=" ../ScalaValidationMacros/index.html">Validation Inception </a></li>
  <li><a href=" ../ScalaValidationExtensions/index.html">Supporting new types </a></li>
  <li><a href=" index.html">Migration from 2.1.x Json API </a></li>
  <li><a href=" ../ScalaValidationMigrationForm/index.html">Migration from 2.1.x Form API </a></li>
  <li><a href=" ../ScalaValidationCookbook/index.html">Cookbook </a></li>
</ul><h3>Main concepts</h3>
<ul>
  <li><a href=" ../ScalaActions/index.html">HTTP programming </a></li>
  <li><a href=" ../ScalaAsync/index.html">Asynchronous HTTP programming </a></li>
  <li><a href=" ../ScalaTemplates/index.html">The template engine </a></li>
  <li><a href=" ../ScalaForms/index.html">HTTP form submission and validation </a></li>
  <li><a href=" ../ScalaJson/index.html">Working with JSON </a></li>
  <li><a href=" ../ScalaXmlRequests/index.html">Working with XML </a></li>
  <li><a href=" ../ScalaFileUpload/index.html">Handling file upload </a></li>
  <li><a href=" ../ScalaDatabase/index.html">Accessing an SQL database </a></li>
  <li><a href=" ../ScalaCache/index.html">Using the Cache </a></li>
  <li><a href=" ../ScalaWS/index.html">Calling WebServices </a></li>
  <li><a href=" ../ScalaAkka/index.html">Integrating with Akka </a></li>
  <li><a href=" ../ScalaI18N/index.html">Internationalization </a></li>
  <li><a href=" ../ScalaGlobal/index.html">The application Global object </a></li>
  <li><a href=" ../ScalaTest/index.html">Testing your application </a></li>
</ul><h3>Advanced topics</h3>
<ul>
  <li><a href=" ../Iteratees/index.html">Handling data streams reactively </a></li>
</ul><h3>Tutorials</h3>
<ul>
  <li><a href=" ../ScalaTodoList/index.html">Your first application </a></li>
</ul>
            </aside>
        </div>

        <style type="text/css">
            @import '../resources/webjars/2.3.0-RC1/prettify/prettify.css';
        </style>
        <script type="text/javascript" charset="utf-8" src='../resources/webjars/2.3.0-RC1/prettify/prettify.js'></script>
        <script type="text/javascript" charset="utf-8" src='../resources/webjars/2.3.0-RC1/prettify/lang-scala.js'></script>
        <script type="text/javascript">
            $(function() {
                window.prettyPrint && prettyPrint();
            });
        </script>

    </body>
</html>

<!-- Localized -->