

<html>
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
        <title>ScalaValidationExtensions</title>
        <link rel="stylesheet" media="screen" href="../resources/style/main.css"></link>
        <script type="text/javascript" src='../resources/webjars/2.3.0-RC1/jquery/jquery.min.js'></script>
        <script type="text/javascript" src="../resources/style/main.js"></script>
    </head>
    <body>

        <section id="top">
            <div class="wrapper">
                <h1><a href="../index.html">Manual, tutorials & references</a></h1>
                <nav>
                    <span class="versions">
                        <span>Browse APIs</span>
                        <select onchange="document.location=this.value">
                            <option selected disabled>Select language</option>
                            <option value="/@documentation/api/scala/index.html">Scala</option>
                            <option value="/@documentation/api/java/index.html">Java</option>
                        </select>
                    </span>
                </nav>
            </div>
        </section>

        <div id="content" class="wrapper doc">
            <article id="main">
                
                    <h1>Extensions: Supporting new types</h1><p>The validation API is designed to be easily extensible. Supporting new types is just a matter of providing the appropriate set of Rules and Writes.</p><p>In this documentation, we&rsquo;ll study the implementation of the Json support. All extensions are to be defined in a similar fashion. The total amount of code needed is rather small, but there&rsquo;s best practices you need to follow.</p><h2>Rules</h2><p>The first step is to define what we call primitive rules. Primitive rules is a set of rules on which you could build any complex validation.</p><p>The base of all Rules is the capacity to extract a subset of some input data.</p><p>For the type <code>JsValue</code>, we need to be able to extract a <code>JsValue</code> at a given <code>Path</code>:</p>
<pre class="prettyprint"><code class="language-scala">implicit def pickInJson[O](p: Path): Rule[JsValue, JsValue] =
  Rule[JsValue, JsValue] { json =&gt;
    pathToJsPath(p)(json) match {
      case Nil =&gt; Failure(Seq(Path -&gt; Seq(ValidationError(&quot;error.required&quot;))))
      case js :: _ =&gt; Success(js)
    }
  }</code></pre><p>Now we are able to do this:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json._
import play.api.data.mapping._

val js = Json.obj(
  &quot;field1&quot; -&gt; &quot;alpha&quot;,
  &quot;field2&quot; -&gt; 123L,
  &quot;field3&quot; -&gt; Json.obj(
    &quot;field31&quot; -&gt; &quot;beta&quot;,
    &quot;field32&quot;-&gt; 345))

val pick = From[JsValue]{ __ =&gt;
  import play.api.data.mapping.json.Rules._
  (__ \ &quot;field2&quot;).read[JsValue]
}

pick.validate(js) === Success(JsNumber(123))</code></pre><p>Which is nice, but is would be much more convenient if we could extract that value as an <code>Int</code>.</p><p>One solution is to write the following method:</p>
<pre class="prettyprint"><code class="language-scala">implicit def pickIntInJson[O](p: Path): Rule[JsValue, JsValue] = ???
</code></pre><p>But we would end up copying 90% of the code we already wrote.<br/>Instead of doing so, we&rsquo;re going to make <code>pickInJson</code> a bit smarter by adding an implicit parameter:</p>
<pre class="prettyprint"><code class="language-scala">implicit def pickInJson[O](p: Path)(implicit r: Rule[JsValue, O]): Rule[JsValue, O] =
Rule[JsValue, JsValue] { json =&gt;
  pathToJsPath(p)(json) match {
    case Nil =&gt; Failure(Seq(Path -&gt; Seq(ValidationError(&quot;error.required&quot;))))
    case js :: _ =&gt; Success(js)
  }
}.compose(r)</code></pre><p>The now all we have to do is to write a <code>Rule[JsValue, O]</code>, and we automatically get the <code>Path =&gt; Rule[JsValue, O]</code> we&rsquo;re interested in. The rest is just a matter of defining all the prmitives rules, for example:</p>
<pre class="prettyprint"><code class="language-scala">private def jsonAs[T](f: PartialFunction[JsValue, Validation[ValidationError, T]])(args: Any*) =
  Rule.fromMapping[JsValue, T](
    f.orElse{ case j =&gt; Failure(Seq(ValidationError(&quot;validation.invalid&quot;, args: _*)))
  })

implicit def string = jsonAs[String] {
  case JsString(v) =&gt; Success(v)
}(&quot;String&quot;)

implicit def boolean = jsonAs[Boolean]{
  case JsBoolean(v) =&gt; Success(v)
}(&quot;Boolean&quot;)
// ...</code></pre><p>The types you generally want to support natively are:</p>
<ul>
  <li>String</li>
  <li>Boolean</li>
  <li>Int</li>
  <li>Short</li>
  <li>Long</li>
  <li>Float</li>
  <li>Double</li>
  <li>java BigDecimal</li>
  <li>scala BigDecimal</li>
</ul><h2>Higher order Rules</h2><p>Supporting primitives is nice, but not enough. Users are going to deal with <code>Seq</code> and <code>Option</code>. We need to support those types too.</p><h3>Option</h3><p>What we want to do is to implement a function that takes a <code>Path =&gt; Rule[JsValue, O]</code>, an lift it into a <code>Path =&gt; Rule[JsValue, Option[O]]</code> for any type <code>O</code>. The reason we&rsquo;re working on the fully defined <code>Path =&gt; Rule[JsValue, O]</code> and not just <code>Rule[JsValue, O]</code> is because a non existent <code>Path</code> must be validated as a <code>Success(None)</code>. If we were to use <code>pickInJson</code> on a <code>Rule[JsValue, Option[O]]</code>, we would end up with a <code>Failure</code> in the case of non-existing <code>Path</code>.</p><p>The <code>play.api.data.mapping.DefaultRules[I]</code> traits provides a helper for building the desired method. It&rsquo;s signature is:</p>
<pre class="prettyprint"><code class="language-scala">protected def opt[J, O](r: =&gt; Rule[J, O], noneValues: Rule[I, I]*)(implicit pick: Path =&gt; Rule[I, I], coerce: Rule[I, J]): Path = Rule[I, O]
</code></pre>
<ul>
  <li><code>noneValues</code> is a List of all the values we should consider to be <code>None</code>. For Json that would be <code>JsNull</code>.</li>
  <li><code>pick</code> is a extractor. It&rsquo;s going to extract a subtree.</li>
  <li><code>coerce</code> is a type conversion <code>Rule</code></li>
  <li><code>r</code> is a <code>Rule</code> to be applied on the data if they are found</li>
</ul><p>What you do is to use this method to implement a specialized version for your type.<br/>For example it&rsquo;s defined this way for Json:</p>
<pre class="prettyprint"><code class="language-scala">def option[J, O](r: =&gt; Rule[J, O], noneValues: Rule[JsValue, JsValue]*)(implicit pick: Path =&gt; Rule[JsValue, JsValue], coerce: Rule[JsValue, J]): Path =&gt; Rule[JsValue, Option[O]]
    = super.opt[J, O](r, (jsNull.fmap(n =&gt; n: JsValue) +: noneValues):_*)
</code></pre><p>Basically it&rsquo;s just the same, but we are now only supporting <code>JsValue</code>. We are also adding JsNull is the list of None-ish values.</p><p>Despite the type signature funkiness, this function is actually <strong>really</strong> simple to use:</p>
<pre class="prettyprint"><code class="language-scala">val maybeEmail = From[JsValue]{ __ =&gt;
  import play.api.data.mapping.json.Rules._
  (__ \ &quot;email&quot;).read(option(email))
}

maybeEmail.validate(Json.obj(&quot;email&quot; -&gt; &quot;foo@bar.com&quot;)) === Success(Some(&quot;foo@bar.com&quot;))
maybeEmail.validate(Json.obj(&quot;email&quot; -&gt; &quot;baam!&quot;)) === Failure(Seq((Path \ &quot;email&quot;, Seq(ValidationError(&quot;error.email&quot;)))))
maybeEmail.validate(Json.obj(&quot;email&quot; -&gt; JsNull)) === Success(None)
maybeEmail.validate(Json.obj()) === Success(None)</code></pre><p>Alright, so now we can explicitly define rules for optional data.</p><p>But what if we write <code>(__ \ &quot;age&quot;).read[Option[Int]]</code> ? It does not compile !<br/>We need to define an implicit rule for that:</p>
<pre class="prettyprint"><code class="language-scala">implicit def option[O](p: Path)(implicit pick: Path =&gt; Rule[JsValue, JsValue], coerce: Rule[JsValue, O]): Rule[JsValue, Option[O]] =
    option(Rule.zero[O])(pick, coerce)(p)
</code></pre>
<pre class="prettyprint"><code class="language-scala">val maybeAge = From[JsValue]{ __ =&gt;
  import play.api.data.mapping.json.Rules._
  (__ \ &quot;age&quot;).read[Option[Int]]
}

// maybeEmail.validate(Json.obj(&quot;age&quot; -&gt; 28)) === Success(Some(28))
maybeAge.validate(Json.obj(&quot;age&quot; -&gt; &quot;baam!&quot;)) === Failure(Seq((Path \ &quot;age&quot;, Seq(ValidationError(&quot;error.invalid&quot;, &quot;Int&quot;)))))
maybeAge.validate(Json.obj(&quot;age&quot; -&gt; JsNull)) === Success(None)
maybeAge.validate(Json.obj()) === Success(None)</code></pre><h3>Lazyness</h3><p>It&rsquo;s very important that every Rule is completely lazily evaluated . The reason for that is that you may be validating recursive types:</p>
<pre class="prettyprint"><code class="language-scala">val u = RecUser(
  &quot;bob&quot;,
  Seq(RecUser(&quot;tom&quot;)))

lazy val w: Rule[JsValue, RecUser] = From[JsValue]{ __ =&gt;
  import play.api.data.mapping.json.Rules._
  ((__ \ &quot;name&quot;).read[String] ~
   (__ \ &quot;friends&quot;).read(seq(w)))(RecUser.apply _) // !!! recursive rule definition
}</code></pre><h2>Writes</h2><p>Writes are implemented in a similar fashion, but a generally easier to implement. You start by defining a function for writing at a given path:</p>
<pre class="prettyprint"><code class="language-scala">implicit def writeJson[I](path: Path)(implicit w: Write[I, JsValue]): Write[I, JsObject] = ???</code></pre><p>And you then defines all the primitive writes:</p>
<pre class="prettyprint"><code class="language-scala">implicit def anyval[T &lt;: AnyVal] = ???</code></pre><h3>Monoid</h3><p>In order to be able to use writes combinators, you also need to create an implementation of <code>Monoid</code> for your output type. For example, to create a complex write of <code>JsObject</code>, we had to implement a <code>Monoid[JsObject]</code>:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.functional.Monoid
implicit def jsonMonoid = new Monoid[JsObject] {
  def append(a1: JsObject, a2: JsObject) = a1 deepMerge a2
  def identity = Json.obj()
}</code></pre><p>from there you&rsquo;re able to create complex writes like:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json._
import play.api.data.mapping._
import play.api.data.mapping.json.Writes._
import play.api.libs.functional.syntax.unlift

val userWrite = To[JsObject] { __ =&gt;
  import play.api.data.mapping.json.Writes._
  ((__ \ &quot;name&quot;).write[String] and
   (__ \ &quot;age&quot;).write[Int] and
   (__ \ &quot;email&quot;).write[Option[String]] and
   (__ \ &quot;isAlive&quot;).write[Boolean])(unlift(User.unapply _))
}</code></pre><h2>Testing</h2><p>We highly recommend you to test your rules as much as possible. There&rsquo;s a few tricky cases you need to handle properly. You should port the tests in <code>RulesSpec.scala</code> and use them on your rules.</p>
<blockquote><p><strong>Next:</strong> - <a href=" ../ScalaValidationCookbook/index.html">Cookbook </a></p>
</blockquote>
                
            </article>
            <aside>
                <h3>Play data validation API</h3>
<ul>
  <li><a href=" ../ScalaValidation/index.html">Introduction </a></li>
  <li><a href=" ../ScalaValidationRule/index.html">Validation and transformation with Rule </a></li>
  <li><a href=" ../ScalaValidationRuleCombinators/index.html">Complex validation: combining Rules </a></li>
  <li><a href=" ../ScalaValidationWrite/index.html">Serialization with Write </a></li>
  <li><a href=" ../ScalaValidationWriteCombinators/index.html">Complex serialization: combining Writes </a></li>
  <li><a href=" ../ScalaValidationForm/index.html">Forms template helpers </a></li>
  <li><a href=" ../ScalaValidationMacros/index.html">Validation Inception </a></li>
  <li><a href=" index.html">Supporting new types </a></li>
  <li><a href=" ../ScalaValidationMigrationJson/index.html">Migration from 2.1.x Json API </a></li>
  <li><a href=" ../ScalaValidationMigrationForm/index.html">Migration from 2.1.x Form API </a></li>
  <li><a href=" ../ScalaValidationCookbook/index.html">Cookbook </a></li>
</ul><h3>Main concepts</h3>
<ul>
  <li><a href=" ../ScalaActions/index.html">HTTP programming </a></li>
  <li><a href=" ../ScalaAsync/index.html">Asynchronous HTTP programming </a></li>
  <li><a href=" ../ScalaTemplates/index.html">The template engine </a></li>
  <li><a href=" ../ScalaForms/index.html">HTTP form submission and validation </a></li>
  <li><a href=" ../ScalaJson/index.html">Working with JSON </a></li>
  <li><a href=" ../ScalaXmlRequests/index.html">Working with XML </a></li>
  <li><a href=" ../ScalaFileUpload/index.html">Handling file upload </a></li>
  <li><a href=" ../ScalaDatabase/index.html">Accessing an SQL database </a></li>
  <li><a href=" ../ScalaCache/index.html">Using the Cache </a></li>
  <li><a href=" ../ScalaWS/index.html">Calling WebServices </a></li>
  <li><a href=" ../ScalaAkka/index.html">Integrating with Akka </a></li>
  <li><a href=" ../ScalaI18N/index.html">Internationalization </a></li>
  <li><a href=" ../ScalaGlobal/index.html">The application Global object </a></li>
  <li><a href=" ../ScalaTest/index.html">Testing your application </a></li>
</ul><h3>Advanced topics</h3>
<ul>
  <li><a href=" ../Iteratees/index.html">Handling data streams reactively </a></li>
</ul><h3>Tutorials</h3>
<ul>
  <li><a href=" ../ScalaTodoList/index.html">Your first application </a></li>
</ul>
            </aside>
        </div>

        <style type="text/css">
            @import '../resources/webjars/2.3.0-RC1/prettify/prettify.css';
        </style>
        <script type="text/javascript" charset="utf-8" src='../resources/webjars/2.3.0-RC1/prettify/prettify.js'></script>
        <script type="text/javascript" charset="utf-8" src='../resources/webjars/2.3.0-RC1/prettify/lang-scala.js'></script>
        <script type="text/javascript">
            $(function() {
                window.prettyPrint && prettyPrint();
            });
        </script>

    </body>
</html>

<!-- Localized -->