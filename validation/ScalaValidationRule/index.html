

<html>
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
        <title>ScalaValidationRule</title>
        <link rel="stylesheet" media="screen" href="../resources/style/main.css"></link>
        <script type="text/javascript" src='../resources/webjars/2.3.0-RC1/jquery/jquery.min.js'></script>
        <script type="text/javascript" src="../resources/style/main.js"></script>
    </head>
    <body>

        <section id="top">
            <div class="wrapper">
                <h1><a href="../index.html">Manual, tutorials & references</a></h1>
                <nav>
                    <span class="versions">
                        <span>Browse APIs</span>
                        <select onchange="document.location=this.value">
                            <option selected disabled>Select language</option>
                            <option value="/@documentation/api/scala/index.html">Scala</option>
                            <option value="/@documentation/api/java/index.html">Java</option>
                        </select>
                    </span>
                </nav>
            </div>
        </section>

        <div id="content" class="wrapper doc">
            <article id="main">
                
                    <h1>Validating and transforming data</h1><h2>Introduction</h2><p>The API is designed around the concept of <code>Rule</code>. A <code>Rule[I, O]</code> defines a way to validate and coerce data, from type <code>I</code> to type <code>O</code>. It&rsquo;s basically a function <code>I =&gt; Validation[O]</code>, where <code>I</code> is the type of the input to validate, and <code>O</code> is the expected output type.</p><h2>A simple example</h2><p>Let&rsquo;s say you want to coerce a <code>String</code> into an <code>Float</code>.<br/>All you need to do is to define a <code>Rule</code> from String to Float:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.data.mapping._
def isFloat: Rule[String, Float] = ???</code></pre><p>When a <code>String</code> is parsed into an <code>Float</code>, two scenario are possible, either:</p>
<ul>
  <li>The <code>String</code> can be parsed as a <code>Float</code>.</li>
  <li>The <code>String</code> can NOT be parsed as a <code>Float</code></li>
</ul><p>In a typical Scala application, you would use <code>Float.parseFloat</code> to parse a <code>String</code>. On an &ldquo;invalid&rdquo; value, this method throws a <code>NumberFormatException</code>.</p><p>When validating data, we&rsquo;d certainly prefer to avoid exceptions, as the failure case is expected to happen quite often.</p><p>Furthermore, your application should handle it properly, for example by sending a nice error message to the end user. The execution flow of the application should not be altered by a parsing failure, but rather be part of the process. Exceptions are definitely not the appropriate tool for the job.</p><p>Back, to our <code>Rule</code>. For now we&rsquo;ll not implement <code>isFloat</code>, actually the validation API comes with a number of built-in Rules, including the <code>Float</code> parsing <code>Rule[String, Float]</code>.</p><p>All you have to do is import the default Rules.</p>
<pre class="prettyprint"><code class="language-scala">scala&gt; import play.api.data.mapping.Rules
import play.api.data.mapping.Rules

scala&gt; :t Rules.float                   // the :t command shows the type
play.api.data.mapping.Rule[String,Float]
</code></pre><p>Let&rsquo;s now test it against different String values:</p>
<pre class="prettyprint"><code class="language-scala">Rules.float.validate(&quot;1&quot;) === Success(1.0f)
Rules.float.validate(&quot;-13.7&quot;) === Success(-13.7f)

Rules.float.validate(&quot;abc&quot;) === Failure(Seq((Path,Seq(ValidationError(&quot;error.number&quot;, &quot;Float&quot;)))))</code></pre>
<blockquote><p><code>Rule</code> is typesafe. You can&rsquo;t apply a <code>Rule</code> on an unsupported type, the compiler won&rsquo;t let you:</p>
  <pre class="prettyprint"><code class="language-scala">scala&gt; :t Rules.float
play.api.data.mapping.Rule[String,Float]
</code></pre>
  <pre class="prettyprint"><code class="language-scala">scala&gt; Rules.float.validate(Seq(32))
&lt;console&gt;:9: error: type mismatch;
 found   : Seq[Int]
 required: String
              Rules.float.validate(Seq(32))
                                      ^
</code></pre>
</blockquote><p>&ldquo;abc&rdquo; is not a valid <code>Float</code> but no exception was thrown. Instead of relying on exceptions, <code>validate</code> is returning an object of type <code>Validation</code> (here <code>VA</code> is just a fancy alias for a special kind of validation).</p><p><code>Validation</code> represents possible outcomes of Rule application, it can be either :</p>
<ul>
  <li>A <code>Success</code>, holding the value being validated<br/> When we use <code>Rule.float</code> on &ldquo;1&rdquo;, since &ldquo;1&rdquo; is a valid representation of a <code>Float</code>, it returns <code>Success(1.0)</code></li>
  <li>A <code>Failure</code>, containing all the errors.<br/> When we use <code>Rule.float</code> on &ldquo;abc&rdquo;, since &ldquo;abc&rdquo; is <em>not</em> a valid representation of a <code>Float</code>, it returns <code>Failure(List((/,List(ValidationError(validation.type-mismatch,WrappedArray(Float))))))</code>. That <code>Failure</code> tells us all there is to know: it give us a nice message explaining what has failed, and even gives us a parameter <code>&quot;Float&quot;</code>, indicating which type the <code>Rule</code> expected to find.</li>
</ul>
<blockquote><p>Note that <code>Validation</code> is a parameterized type. Just like <code>Rule</code>, it keeps track of the input and output types.<br/>The method <code>validate</code> of a <code>Rule[I, O]</code> always return a <code>VA[I, O]</code></p>
</blockquote><h2>Defining your own Rules</h2><p>Creating a new <code>Rule</code> is almost as simple as creating a new function.<br/>All there is to do it to pass a function <code>I =&gt; Validation[I, O]</code> to <code>Rule.fromMapping</code>.</p><p>This example creates a new <code>Rule</code> trying to get the first element of a <code>List[Int]</code>.<br/>In case of an empty <code>List[Int]</code>, the rule should return a <code>Failure</code>.</p>
<pre class="prettyprint"><code class="language-scala">import play.api.data.mapping._

val headInt: Rule[List[Int], Int] = Rule.fromMapping {
  case Nil =&gt; Failure(Seq(ValidationError(&quot;error.emptyList&quot;)))
  case head :: _ =&gt; Success(head)
}</code></pre>
<pre class="prettyprint"><code class="language-scala">headInt.validate(List(1, 2, 3, 4, 5)) === Success(1)
headInt.validate(Nil) === Failure(Seq((Path, Seq(ValidationError(&quot;error.emptyList&quot;)))))</code></pre><p>We can make this rule a bit more generic:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.data.mapping._

def head[T]: Rule[List[T], T] = Rule.fromMapping {
  case Nil =&gt; Failure(Seq(ValidationError(&quot;error.emptyList&quot;)))
  case head :: _ =&gt; Success(head)
}</code></pre>
<pre class="prettyprint"><code class="language-scala">head.validate(List(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;)) === Success(&#39;a&#39;)
head.validate(List[Char]()) === Failure(Seq((Path, Seq(ValidationError(&quot;error.emptyList&quot;)))))</code></pre><h2>Composing Rules</h2><p>Rules composition is very important in this API. <code>Rule</code> composition means that, given two <code>Rule</code> <code>a</code> and <code>b</code>, we can easily create a new Rule <code>c</code>.</p><p>There two different types of composition</p><h3>&ldquo;Sequential&rdquo; composition</h3><p>Sequential composition means that given two rules <code>a: Rule[I, J]</code> and <code>b: Rule[J, O]</code>, we can create a new rule <code>c: Rule[I, O]</code>.</p><p>Consider the following example: We want to write a <code>Rule</code> that given a <code>List[String]</code>, takes the first <code>String</code> in that <code>List</code>, and try to parse it as a <code>Float</code>.</p><p>We already have defined:</p>
<ol>
  <li><code>head: Rule[List[T], T]</code> returns the first element of a <code>List</code></li>
  <li><code>float: Rule[String, Float]</code> parses a <code>String</code> into a <code>Float</code></li>
</ol><p>We&rsquo;ve done almost all the work already. We just have to create a new <code>Rule</code> the applies the first <code>Rule</code> and if it return a <code>Success</code>, apply the second <code>Rule</code>.</p><p>It would be fairly easy to create such a <code>Rule</code> &ldquo;manually&rdquo;, but we don&rsquo;t have to. A method doing just that is already available:</p>
<pre class="prettyprint"><code class="language-scala">val firstFloat: Rule[List[String], Float] = head.compose(float)</code></pre>
<pre class="prettyprint"><code class="language-scala">firstFloat.validate(List(&quot;1&quot;, &quot;2&quot;)) === Success(1.0f)
firstFloat.validate(List(&quot;1.2&quot;, &quot;foo&quot;)) === Success(1.2f)</code></pre><p>If the list is empty, we get the error from <code>head</code></p>
<pre class="prettyprint"><code class="language-scala">firstFloat.validate(List()) === Failure(Seq((Path,Seq(ValidationError(&quot;error.emptyList&quot;)))))</code></pre><p>If the first element is not parseable, we get the error from <code>Rules.float</code>.</p>
<pre class="prettyprint"><code class="language-scala">firstFloat.validate(List(&quot;foo&quot;, &quot;2&quot;)) === Failure(Seq((Path,Seq(ValidationError(&quot;error.number&quot;, &quot;Float&quot;)))))</code></pre><p>Of course everything is still typesafe:</p>
<pre class="prettyprint"><code class="language-scala">scala&gt; firstFloat.validate(List(1, 2, 3))
&lt;console&gt;:20: error: type mismatch;
 found   : Int(1)
 required: String
              firstFloat.validate(List(1, 2, 3))
                                       ^
</code></pre><h4>Improving reporting.</h4><p>All is fine with our new <code>Rule</code> but the error reporting when we parse an element is not perfect yet.<br/>When a parsing error happens, the <code>Failure</code> does not tells us that it happened on the first element of the <code>List</code>.</p><p>To fix that, we can pass an additionnal parameter to <code>compose</code>:</p>
<pre class="prettyprint"><code class="language-scala">val firstFloat2: Rule[List[String],Float] = head.compose(Path \ 0)(Rules.float)
firstFloat2.validate(List(&quot;foo&quot;, &quot;2&quot;)) === Failure(Seq((Path \ 0, Seq(ValidationError(&quot;error.number&quot;, &quot;Float&quot;)))))
//                                       NOTICE THE INDEX HERE ^</code></pre><h3>&ldquo;Parallel&rdquo; composition</h3><p>Parallel composition means that given two rules <code>a: Rule[I, O]</code> and <code>b: Rule[I, O]</code>, we can create a new rule <code>c: Rule[I, O]</code>.</p><p>This form of composition if almost exclusively used for the particular case of rule that are purely constraint, that is, a <code>Rule[I, I]</code> checking a value of type <code>I</code> satisfies a predicate, but does not transform that value.</p><p>Consider the following example: We want to write a <code>Rule</code> that given a <code>Int</code>, check that this <code>Int</code> is positive and even.<br/>The validation API already provides <code>Rules.min</code>, we have to define <code>even</code> ourselves:</p>
<pre class="prettyprint"><code class="language-scala">val positive: Rule[Int,Int] = Rules.min(0)
val even: Rule[Int,Int] = Rules.validateWith[Int](&quot;error.even&quot;){ _ % 2 == 0 }</code></pre><p>Now we can compose those rules using <code>|+|</code></p>
<pre class="prettyprint"><code class="language-scala">val positiveAndEven: Rule[Int,Int] = positive |+| even</code></pre><p>Let&rsquo;s test our new <code>Rule</code>:</p>
<pre class="prettyprint"><code class="language-scala">positiveAndEven.validate(12) === Success(12)
positiveAndEven.validate(-12) === Failure(Seq((Path, List(ValidationError(&quot;error.min&quot;, 0)))))
positiveAndEven.validate(13) === Failure(Seq((Path, List(ValidationError(&quot;error.even&quot;)))))
positiveAndEven.validate(-13) ===  Failure(Seq((Path,Seq(ValidationError(&quot;error.min&quot;,0), ValidationError(&quot;error.even&quot;)))))</code></pre><p>Note that both rules are applied. If both fail, we get two <code>ValidationError</code>.</p>
<blockquote><p><strong>Next:</strong> - <a href=" ../ScalaValidationRuleCombinators/index.html">Complex validation with Rule combinators </a></p>
</blockquote>
                
            </article>
            <aside>
                <h3>Play data validation API</h3>
<ul>
  <li><a href=" ../ScalaValidation/index.html">Introduction </a></li>
  <li><a href=" index.html">Validation and transformation with Rule </a></li>
  <li><a href=" ../ScalaValidationRuleCombinators/index.html">Complex validation: combining Rules </a></li>
  <li><a href=" ../ScalaValidationWrite/index.html">Serialization with Write </a></li>
  <li><a href=" ../ScalaValidationWriteCombinators/index.html">Complex serialization: combining Writes </a></li>
  <li><a href=" ../ScalaValidationForm/index.html">Forms template helpers </a></li>
  <li><a href=" ../ScalaValidationMacros/index.html">Validation Inception </a></li>
  <li><a href=" ../ScalaValidationExtensions/index.html">Supporting new types </a></li>
  <li><a href=" ../ScalaValidationMigrationJson/index.html">Migration from 2.1.x Json API </a></li>
  <li><a href=" ../ScalaValidationMigrationForm/index.html">Migration from 2.1.x Form API </a></li>
  <li><a href=" ../ScalaValidationCookbook/index.html">Cookbook </a></li>
</ul><h3>Main concepts</h3>
<ul>
  <li><a href=" ../ScalaActions/index.html">HTTP programming </a></li>
  <li><a href=" ../ScalaAsync/index.html">Asynchronous HTTP programming </a></li>
  <li><a href=" ../ScalaTemplates/index.html">The template engine </a></li>
  <li><a href=" ../ScalaForms/index.html">HTTP form submission and validation </a></li>
  <li><a href=" ../ScalaJson/index.html">Working with JSON </a></li>
  <li><a href=" ../ScalaXmlRequests/index.html">Working with XML </a></li>
  <li><a href=" ../ScalaFileUpload/index.html">Handling file upload </a></li>
  <li><a href=" ../ScalaDatabase/index.html">Accessing an SQL database </a></li>
  <li><a href=" ../ScalaCache/index.html">Using the Cache </a></li>
  <li><a href=" ../ScalaWS/index.html">Calling WebServices </a></li>
  <li><a href=" ../ScalaAkka/index.html">Integrating with Akka </a></li>
  <li><a href=" ../ScalaI18N/index.html">Internationalization </a></li>
  <li><a href=" ../ScalaGlobal/index.html">The application Global object </a></li>
  <li><a href=" ../ScalaTest/index.html">Testing your application </a></li>
</ul><h3>Advanced topics</h3>
<ul>
  <li><a href=" ../Iteratees/index.html">Handling data streams reactively </a></li>
</ul><h3>Tutorials</h3>
<ul>
  <li><a href=" ../ScalaTodoList/index.html">Your first application </a></li>
</ul>
            </aside>
        </div>

        <style type="text/css">
            @import '../resources/webjars/2.3.0-RC1/prettify/prettify.css';
        </style>
        <script type="text/javascript" charset="utf-8" src='../resources/webjars/2.3.0-RC1/prettify/prettify.js'></script>
        <script type="text/javascript" charset="utf-8" src='../resources/webjars/2.3.0-RC1/prettify/lang-scala.js'></script>
        <script type="text/javascript">
            $(function() {
                window.prettyPrint && prettyPrint();
            });
        </script>

    </body>
</html>

<!-- Localized -->