

<html>
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
        <title>ScalaValidationForm</title>
        <link rel="stylesheet" media="screen" href="../resources/style/main.css"></link>
        <script type="text/javascript" src='../resources/webjars/2.3.0-RC1/jquery/jquery.min.js'></script>
        <script type="text/javascript" src="../resources/style/main.js"></script>
    </head>
    <body>

        <section id="top">
            <div class="wrapper">
                <h1><a href="../index.html">Manual, tutorials & references</a></h1>
                <nav>
                    <span class="versions">
                        <span>Browse APIs</span>
                        <select onchange="document.location=this.value">
                            <option selected disabled>Select language</option>
                            <option value="/@documentation/api/scala/index.html">Scala</option>
                            <option value="/@documentation/api/java/index.html">Java</option>
                        </select>
                    </span>
                </nav>
            </div>
        </section>

        <div id="content" class="wrapper doc">
            <article id="main">
                
                    <h1>Form template helpers</h1><p>The validation API is compatible with play&rsquo;s existing <a href="../ScalaForms/index.html">template helpers</a>.<br/>There&rsquo;s one difference though : <strong>you have to use <code>play.api.data.mapping.Form</code></strong> instead of using <code>play.api.data.Form</code>.</p><p>This <code>Form</code> helpers use <code>Rule</code> to validate data, and <code>Write</code> to format form data:</p><h2>Fill a form with initial default values</h2><p>Consider the following example, from play&rsquo;s sample &ldquo;computer database&rdquo; application :</p><p>The <code>edit</code> action renders a form pre-filled with <code>computer</code> data. All we have to do is to create a <code>Form</code> instance using <code>Form.fill</code>:</p>
<pre class="prettyprint"><code class="language-scala">def edit(id: Long) = Action {
  Computer.findById(id).map { computer =&gt;
    Ok(html.editForm(id, Form.fill(computer), Company.options))
  }.getOrElse(NotFound)
}</code></pre>
<blockquote><p>Note we are using <code>play.api.data.mapping.Form</code>, <strong>NOT</strong> <code>play.api.data.Form</code></p>
</blockquote><p>Note that <code>Form.fill</code> needs to find an implicit <code>Write[Computer, UrlFormEncoded]</code>. In this example, we define it in <code>Application.scala</code>:</p>
<pre class="prettyprint"><code class="language-scala">implicit val computerW = To[UrlFormEncoded] { __ =&gt;
  import play.api.data.mapping.Writes._
  ((__ \ &quot;id&quot;).write[Option[Long]] ~
   (__ \ &quot;name&quot;).write[String] ~
   (__ \ &quot;introduced&quot;).write(option(date(&quot;yyyy-MM-dd&quot;))) ~
   (__ \ &quot;discontinued&quot;).write(option(date(&quot;yyyy-MM-dd&quot;))) ~
   (__ \ &quot;company&quot;).write[Option[Long]]) (unlift(Computer.unapply _))
}</code></pre><p>Not only the write object serializes primitive types but it formats data when needed.<br/>In our example, dates will be displayed in the &ldquo;yyyy-MM-dd&rdquo; format.</p><p><code>Form.fill</code> writes a <code>Computer</code> using <code>computerW</code>, and the resulting <code>Map[String, Seq[String]]</code> is then used by the <code>editForm</code> templates:</p>
<pre class="prettyprint"><code class="language-scala">@(id: Long, computerForm: play.api.data.mapping.Form[Computer], companies : Seq[(String, String)])

@main {
	// form definition
}
</code></pre><p>From there, all the <a href="../ScalaForms/index.html">template helpers</a> work exactly as they used to :</p>
<pre class="prettyprint"><code class="language-scala">@inputText(computerForm(&quot;name&quot;), &#39;_label -&gt; &quot;Computer name&quot;)
</code></pre><h2>Binding form data</h2><p>The Form object uses a <code>Rule</code> to bind and validate data from a request body :</p>
<pre class="prettyprint"><code class="language-scala">def update(id: Long) = Action(parse.urlFormEncoded) { implicit request =&gt;
  val r = computerValidation.validate(request.body)
  r match {
    case Failure(_) =&gt; BadRequest(html.editForm(id, Form(request.body, r), Company.options))
    case Success(computer) =&gt; {
      Computer.update(id, computer)
      Home.flashing(&quot;success&quot; -&gt; &quot;Computer %s has been updated&quot;.format(computer.name))
    }
  }
}</code></pre><p>The Rule <code>computerValidation</code> is defined below.<br/>Any custom format should match the <code>Form.fill</code> definition and be specified as a <code>read()</code> option.</p>
<pre class="prettyprint"><code class="language-scala">implicit val computerValidation = From[UrlFormEncoded] { __ =&gt;
  import play.api.data.mapping.Rules._
  ((__ \ &quot;id&quot;).read(ignored[UrlFormEncoded, Option[Long]](None)) ~
   (__ \ &quot;name&quot;).read(notEmpty) ~
   (__ \ &quot;introduced&quot;).read(option(date(&quot;yyyy-MM-dd&quot;))) ~
   (__ \ &quot;discontinued&quot;).read(option(date(&quot;yyyy-MM-dd&quot;))) ~
   (__ \ &quot;company&quot;).read[Option[Long]]) (Computer.apply _)
}</code></pre>
<blockquote><p><strong>Next:</strong> - <a href="../ScalaValidationMacros/index.html">Validation Inception</a></p>
</blockquote>
                
            </article>
            <aside>
                <h3>Play data validation API</h3>
<ul>
  <li><a href=" ../ScalaValidation/index.html">Introduction </a></li>
  <li><a href=" ../ScalaValidationRule/index.html">Validation and transformation with Rule </a></li>
  <li><a href=" ../ScalaValidationRuleCombinators/index.html">Complex validation: combining Rules </a></li>
  <li><a href=" ../ScalaValidationWrite/index.html">Serialization with Write </a></li>
  <li><a href=" ../ScalaValidationWriteCombinators/index.html">Complex serialization: combining Writes </a></li>
  <li><a href=" index.html">Forms template helpers </a></li>
  <li><a href=" ../ScalaValidationMacros/index.html">Validation Inception </a></li>
  <li><a href=" ../ScalaValidationExtensions/index.html">Supporting new types </a></li>
  <li><a href=" ../ScalaValidationMigrationJson/index.html">Migration from 2.1.x Json API </a></li>
  <li><a href=" ../ScalaValidationMigrationForm/index.html">Migration from 2.1.x Form API </a></li>
  <li><a href=" ../ScalaValidationCookbook/index.html">Cookbook </a></li>
</ul><h3>Main concepts</h3>
<ul>
  <li><a href=" ../ScalaActions/index.html">HTTP programming </a></li>
  <li><a href=" ../ScalaAsync/index.html">Asynchronous HTTP programming </a></li>
  <li><a href=" ../ScalaTemplates/index.html">The template engine </a></li>
  <li><a href=" ../ScalaForms/index.html">HTTP form submission and validation </a></li>
  <li><a href=" ../ScalaJson/index.html">Working with JSON </a></li>
  <li><a href=" ../ScalaXmlRequests/index.html">Working with XML </a></li>
  <li><a href=" ../ScalaFileUpload/index.html">Handling file upload </a></li>
  <li><a href=" ../ScalaDatabase/index.html">Accessing an SQL database </a></li>
  <li><a href=" ../ScalaCache/index.html">Using the Cache </a></li>
  <li><a href=" ../ScalaWS/index.html">Calling WebServices </a></li>
  <li><a href=" ../ScalaAkka/index.html">Integrating with Akka </a></li>
  <li><a href=" ../ScalaI18N/index.html">Internationalization </a></li>
  <li><a href=" ../ScalaGlobal/index.html">The application Global object </a></li>
  <li><a href=" ../ScalaTest/index.html">Testing your application </a></li>
</ul><h3>Advanced topics</h3>
<ul>
  <li><a href=" ../Iteratees/index.html">Handling data streams reactively </a></li>
</ul><h3>Tutorials</h3>
<ul>
  <li><a href=" ../ScalaTodoList/index.html">Your first application </a></li>
</ul>
            </aside>
        </div>

        <style type="text/css">
            @import '../resources/webjars/2.3.0-RC1/prettify/prettify.css';
        </style>
        <script type="text/javascript" charset="utf-8" src='../resources/webjars/2.3.0-RC1/prettify/prettify.js'></script>
        <script type="text/javascript" charset="utf-8" src='../resources/webjars/2.3.0-RC1/prettify/lang-scala.js'></script>
        <script type="text/javascript">
            $(function() {
                window.prettyPrint && prettyPrint();
            });
        </script>

    </body>
</html>

<!-- Localized -->