

<html>
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
        <title>ScalaValidationRuleCombinators</title>
        <link rel="stylesheet" media="screen" href="../resources/style/main.css"></link>
        <script type="text/javascript" src='../resources/webjars/2.3.0-RC1/jquery/jquery.min.js'></script>
        <script type="text/javascript" src="../resources/style/main.js"></script>
    </head>
    <body>

        <section id="top">
            <div class="wrapper">
                <h1><a href="../index.html">Manual, tutorials & references</a></h1>
                <nav>
                    <span class="versions">
                        <span>Browse APIs</span>
                        <select onchange="document.location=this.value">
                            <option selected disabled>Select language</option>
                            <option value="/@documentation/api/scala/index.html">Scala</option>
                            <option value="/@documentation/api/java/index.html">Java</option>
                        </select>
                    </span>
                </nav>
            </div>
        </section>

        <div id="content" class="wrapper doc">
            <article id="main">
                
                    <h1>Combining Rules</h1><h2>Introduction</h2><p>We&rsquo;ve already explained what a <code>Rule</code> is in <a href=" ../ScalaValidationRule/index.html">the previous chapter </a>.<br/>Those examples were only covering simple rules. However most of the time, rules are used to validate and transform complex hierarchical objects, like <a href="../ScalaValidationJson/index.html">Json</a>, or <a href="../ScalaValidationForm/index.html">Forms</a>.</p><p>The validation API allows complex object rules creation by combining simple rules together. This chapter explains how to create complex rules.</p>
<blockquote><p>Despite examples below are validating Json objects, the API is not dedicated only to Json and can be used on any type.<br/>Please refer to <a href=" ../ScalaValidationJson/index.html">Validating Json </a>, <a href="../ScalaValidationForm/index.html">Validating Forms</a>, and <a href="../ScalaValidationExtensions/index.html">Supporting new types</a> for more information.</p>
</blockquote><h2>Path</h2><p>The validation API defines a class named <code>Path</code>. A <code>Path</code> represents the location of a data among a complex object.<br/>Unlike <code>JsPath</code> it is not related to any specific type. It&rsquo;s just a location in some data.<br/>Most of the time, a <code>Path</code> is our entry point into the Validation API.</p><p>A <code>Path</code> is declared using this syntax:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.data.mapping.Path
val path = Path \ &quot;foo&quot; \ &quot;bar&quot;</code></pre><p><code>Path</code> here is the empty <code>Path</code> object. One may call it the root path.</p><p>A path can also reference indexed data, such as a <code>Seq</code></p>
<pre class="prettyprint"><code class="language-scala">val pi = Path \ &quot;foo&quot; \ 0</code></pre><h3>Extracting data using <code>Path</code></h3><p>Consider the following json:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json._

val js: JsValue = Json.parse(&quot;&quot;&quot;{
  &quot;user&quot;: {
    &quot;name&quot; : &quot;toto&quot;,
    &quot;age&quot; : 25,
    &quot;email&quot; : &quot;toto@jmail.com&quot;,
    &quot;isAlive&quot; : true,
    &quot;friend&quot; : {
      &quot;name&quot; : &quot;tata&quot;,
      &quot;age&quot; : 20,
      &quot;email&quot; : &quot;tata@coldmail.com&quot;
    }
  }
}&quot;&quot;&quot;)</code></pre><p>The first step before validating anything is to be able to access a fragment of the complex object.</p><p>Assuming you&rsquo;d like to validate that <code>friend</code> exists and is valid in this json, you first need to access the object located at <code>user.friend</code> (Javascript notation).</p><h4>The <code>read</code> method</h4><p>We start by creating a <code>Path</code> representing the location of the data we&rsquo;re interested in:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.data.mapping._
val location: Path = Path \ &quot;user&quot; \ &quot;friend&quot;</code></pre><p><code>Path</code> has a <code>read[I, O]</code> method, where <code>I</code> represents the input we&rsquo;re trying to parse, and <code>O</code> the output type. For example, <code>(Path \ &quot;foo&quot;).read[JsValue, Int]</code>, will try to read a value located at path <code>/foo</code> in a <code>JsValue</code> as an <code>Int</code>.</p><p>But let&rsquo;s try something much easier for now:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json.JsValue
import play.api.data.mapping._

val location: Path = Path \ &quot;user&quot; \ &quot;friend&quot;
val findFriend: Rule[JsValue, JsValue] = location.read[JsValue, JsValue]</code></pre><p><code>location.read[JsValue, JsValue]</code> means we&rsquo;re trying to lookup at <code>location</code> in a <code>JsValue</code>, and we expect to find a <code>JsValue</code> there.<br/>In fact we&rsquo;re defining a <code>Rule</code> that is picking a subtree in a <code>JsValue</code>.</p><p>If you try to run that code, the compiler gives you the following error:</p>
<pre class="prettyprint"><code>error: No implicit view available from play.api.data.mapping.Path =&gt; play.api.data.mapping.Rule[play.api.libs.json.JsValue,play.api.libs.json.JsValue].
       val findFriend: Rule[JsValue, JsValue] = location.read[JsValue, JsValue]
                                                             ^
</code></pre><p>The Scala compiler is complaining about not finding an implicit function of type <code>Path =&gt; Rule[JsValue, JsValue]</code>. Indeed, unlike the Json API, you have to provide a method to <strong>lookup</strong> into the data you expect to validate.</p><p>Fortunately, such method already exists. All you have to do is to import it:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.data.mapping.json.Rules._</code></pre>
<blockquote><p>By convention, all useful validation methods for a given type are to be found in an object called <code>Rules</code>. That object contains a bunch of implicits defining how to lookup in the data, and how to coerce some of the possible values of those data into Scala types.</p>
</blockquote><p>With those implicits in scope, we can finally create our <code>Rule</code>:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json.JsValue
import play.api.data.mapping._

val location: Path = Path \ &quot;user&quot; \ &quot;friend&quot;
val findFriend: Rule[JsValue, JsValue] = location.read[JsValue, JsValue]</code></pre><p>Alright, so far we&rsquo;ve defined a <code>Rule</code> looking for some data of type <code>JsValue</code>, located at <code>/user/friend</code> in an object of type <code>JsValue</code>.</p><p>Now we need to apply this <code>Rule</code> to our data:</p>
<pre class="prettyprint"><code class="language-scala">findFriend.validate(js) === Success(Json.parse(&quot;&quot;&quot;{&quot;name&quot;:&quot;tata&quot;,&quot;age&quot;:20,&quot;email&quot;:&quot;tata@coldmail.com&quot;}&quot;&quot;&quot;))</code></pre><p>If we can&rsquo;t find anything, applying a <code>Rule</code> leads to a <code>Failure</code>:</p>
<pre class="prettyprint"><code class="language-scala">(Path \ &quot;foobar&quot;).read[JsValue, JsValue].validate(js) === Failure(Seq((Path \ &quot;foobar&quot;, Seq(ValidationError(&quot;error.required&quot;)))))</code></pre><h3>Type coercion</h3><p>We now are capable of extracting data at a given <code>Path</code>. Let&rsquo;s do it again on a different sub-tree:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.data.mapping._
import play.api.data.mapping.json.Rules._

val age = (Path \ &quot;user&quot; \ &quot;age&quot;).read[JsValue, JsValue]</code></pre><p>Let&rsquo;s apply this new <code>Rule</code>:</p>
<pre class="prettyprint"><code class="language-scala">age.validate(js) === Success(JsNumber(25))</code></pre><p>Again, if the json is invalid:</p>
<pre class="prettyprint"><code class="language-scala">age.validate(Json.obj()) === Failure(Seq((Path \ &quot;user&quot; \ &quot;age&quot;, Seq(ValidationError(&quot;error.required&quot;)))))</code></pre><p>The <code>Failure</code> informs us that it could not find <code>/user/age</code> in that <code>JsValue</code>.</p><p>That example is nice, but we&rsquo;d certainly prefer to extract <code>age</code> as an <code>Int</code> rather than a <code>JsValue</code>.<br/>All we have to do is to change the output type in our <code>Rule</code> definition:</p>
<pre class="prettyprint"><code class="language-scala">val age = (Path \ &quot;user&quot; \ &quot;age&quot;).read[JsValue, Int]</code></pre><p>And apply it:</p>
<pre class="prettyprint"><code class="language-scala">age.validate(js) === Success(25)</code></pre><p>If we try to parse something that is not an <code>Int</code>, we get a <code>Failure</code> with the appropriate Path and error:</p>
<pre class="prettyprint"><code class="language-scala">(Path \ &quot;user&quot; \ &quot;name&quot;).read[JsValue, Int].validate(js) === Failure(Seq((Path \ &quot;user&quot; \ &quot;name&quot;, Seq(ValidationError(&quot;error.invalid&quot;, &quot;Int&quot;)))))</code></pre><p>So scala <em>automagically</em> figures out how to transform a <code>JsValue</code> into an <code>Int</code>. How does this happens ?</p><p>It&rsquo;s fairly simple. The definition of <code>read</code> looks like this:</p>
<pre class="prettyprint"><code class="language-scala">def read[I, O](implicit r: Path =&gt; Rule[I, O]): Rule[I, O]
</code></pre><p>So when use <code>(Path \ &quot;user&quot; \ &quot;age&quot;).read[JsValue, Int]</code>, the compiler looks for an <code>implicit Path =&gt; Rule[JsValue, Int]</code>, which happens to exist in <code>play.api.data.mapping.json.Rules</code>.</p><h3>Validation</h3><p>So far we&rsquo;ve managed to lookup for a <code>JsValue</code> and transform that <code>JsValue</code> into an <code>Int</code>. Problem is: not every <code>Int</code> is a valid age. An age should always be a positive <code>Int</code>.</p>
<pre class="prettyprint"><code class="language-scala">val js = Json.parse(&quot;&quot;&quot;{
  &quot;user&quot;: {
    &quot;age&quot; : -33
  }
}&quot;&quot;&quot;)

val age = (Path \ &quot;user&quot; \ &quot;age&quot;).read[JsValue, Int]</code></pre><p>Our current implementation of <code>age</code> is rather unsatisfying&hellip;</p>
<pre class="prettyprint"><code class="language-scala">age.validate(js) === Success(-33)</code></pre><p>We can fix that very simply using <code>from</code>, and a built-in <code>Rule</code>:</p>
<pre class="prettyprint"><code class="language-scala">val positiveAge = (Path \ &quot;user&quot; \ &quot;age&quot;).from[JsValue](min(0))</code></pre><p>Let&rsquo;s try that again:</p>
<pre class="prettyprint"><code class="language-scala">positiveAge.validate(js) === Failure(Seq((Path \ &quot;user&quot; \ &quot;age&quot;, Seq(ValidationError(&quot;error.min&quot;, 0)))))</code></pre><p>That&rsquo;s better, but still not perfect: 8765 is considered valid:</p>
<pre class="prettyprint"><code class="language-scala">val js2 = Json.parse(&quot;&quot;&quot;{ &quot;user&quot;: { &quot;age&quot; : 8765 } }&quot;&quot;&quot;)
positiveAge.validate(js2) === Success(8765)</code></pre><p>Let&rsquo;s fix our <code>age</code> <code>Rule</code>:</p>
<pre class="prettyprint"><code class="language-scala">val properAge = (Path \ &quot;user&quot; \ &quot;age&quot;).from[JsValue](min(0) |+| max(130))</code></pre><p>and test it:</p>
<pre class="prettyprint"><code class="language-scala">val jsBig = Json.parse(&quot;&quot;&quot;{ &quot;user&quot;: { &quot;age&quot; : 8765 } }&quot;&quot;&quot;)
properAge.validate(jsBig) === Failure(Seq((Path \ &quot;user&quot; \ &quot;age&quot;, Seq(ValidationError(&quot;error.max&quot;, 130)))))</code></pre><h3>Full example</h3>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json.Json
import play.api.data.mapping._
import play.api.data.mapping.json.Rules._

val js = Json.parse(&quot;&quot;&quot;{
  &quot;user&quot;: {
    &quot;name&quot; : &quot;toto&quot;,
    &quot;age&quot; : 25,
    &quot;email&quot; : &quot;toto@jmail.com&quot;,
    &quot;isAlive&quot; : true,
    &quot;friend&quot; : {
      &quot;name&quot; : &quot;tata&quot;,
      &quot;age&quot; : 20,
      &quot;email&quot; : &quot;tata@coldmail.com&quot;
    }
  }
}&quot;&quot;&quot;)

val age = (Path \ &quot;user&quot; \ &quot;age&quot;).from[JsValue](min(0) |+| max(130))
age.validate(js) === Success(25)</code></pre><h2>Combining Rules</h2><p>So far we&rsquo;ve validated only fragments of our json object.<br/>Now we&rsquo;d like to validate the entire object, and turn it into a instance of the <code>User</code> class defined below:</p>
<pre class="prettyprint"><code class="language-scala">case class User(
  name: String,
  age: Int,
  email: Option[String],
  isAlive: Boolean)</code></pre><p>We need to create a <code>Rule[JsValue, User]</code>. Creating this Rule is simply a matter of combining together the rules parsing each field of the json.</p>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json._
import play.api.data.mapping._

val userRule = From[JsValue] { __ =&gt;
  import play.api.data.mapping.json.Rules._
  ((__ \ &quot;name&quot;).read[String] and
   (__ \ &quot;age&quot;).read[Int] and
   (__ \ &quot;email&quot;).read[Option[String]] and
   (__ \ &quot;isAlive&quot;).read[Boolean])(User.apply _)
}</code></pre>
<blockquote><p><strong>Important:</strong> Note that we&rsquo;re importing <code>Rules._</code> <strong>inside</strong> the <code>From[I]{...}</code> block.<br/>It is recommended to always follow this pattern, as it nicely scopes the implicits, avoiding conflicts and accidental shadowing.</p>
</blockquote><p><code>From[JsValue]</code> defines the <code>I</code> type of the rules we&rsquo;re combining. We could have written:</p>
<pre class="prettyprint"><code class="language-scala"> (Path \ &quot;name&quot;).read[JsValue, String] and
 (Path \ &quot;age&quot;).read[JsValue, Int] and
 //...
</code></pre><p>but repeating <code>JsValue</code> all over the place is just not very DRY.</p>
<blockquote><p><strong>Next:</strong> - <a href=" ../ScalaValidationWrite/index.html">Serialization with Write </a><br/><strong>For more examples and snippets:</strong> - <a href=" ../ScalaValidationCookbook/index.html">Cookbook </a></p>
</blockquote>
                
            </article>
            <aside>
                <h3>Play data validation API</h3>
<ul>
  <li><a href=" ../ScalaValidation/index.html">Introduction </a></li>
  <li><a href=" ../ScalaValidationRule/index.html">Validation and transformation with Rule </a></li>
  <li><a href=" index.html">Complex validation: combining Rules </a></li>
  <li><a href=" ../ScalaValidationWrite/index.html">Serialization with Write </a></li>
  <li><a href=" ../ScalaValidationWriteCombinators/index.html">Complex serialization: combining Writes </a></li>
  <li><a href=" ../ScalaValidationForm/index.html">Forms template helpers </a></li>
  <li><a href=" ../ScalaValidationMacros/index.html">Validation Inception </a></li>
  <li><a href=" ../ScalaValidationExtensions/index.html">Supporting new types </a></li>
  <li><a href=" ../ScalaValidationMigrationJson/index.html">Migration from 2.1.x Json API </a></li>
  <li><a href=" ../ScalaValidationMigrationForm/index.html">Migration from 2.1.x Form API </a></li>
  <li><a href=" ../ScalaValidationCookbook/index.html">Cookbook </a></li>
</ul><h3>Main concepts</h3>
<ul>
  <li><a href=" ../ScalaActions/index.html">HTTP programming </a></li>
  <li><a href=" ../ScalaAsync/index.html">Asynchronous HTTP programming </a></li>
  <li><a href=" ../ScalaTemplates/index.html">The template engine </a></li>
  <li><a href=" ../ScalaForms/index.html">HTTP form submission and validation </a></li>
  <li><a href=" ../ScalaJson/index.html">Working with JSON </a></li>
  <li><a href=" ../ScalaXmlRequests/index.html">Working with XML </a></li>
  <li><a href=" ../ScalaFileUpload/index.html">Handling file upload </a></li>
  <li><a href=" ../ScalaDatabase/index.html">Accessing an SQL database </a></li>
  <li><a href=" ../ScalaCache/index.html">Using the Cache </a></li>
  <li><a href=" ../ScalaWS/index.html">Calling WebServices </a></li>
  <li><a href=" ../ScalaAkka/index.html">Integrating with Akka </a></li>
  <li><a href=" ../ScalaI18N/index.html">Internationalization </a></li>
  <li><a href=" ../ScalaGlobal/index.html">The application Global object </a></li>
  <li><a href=" ../ScalaTest/index.html">Testing your application </a></li>
</ul><h3>Advanced topics</h3>
<ul>
  <li><a href=" ../Iteratees/index.html">Handling data streams reactively </a></li>
</ul><h3>Tutorials</h3>
<ul>
  <li><a href=" ../ScalaTodoList/index.html">Your first application </a></li>
</ul>
            </aside>
        </div>

        <style type="text/css">
            @import '../resources/webjars/2.3.0-RC1/prettify/prettify.css';
        </style>
        <script type="text/javascript" charset="utf-8" src='../resources/webjars/2.3.0-RC1/prettify/prettify.js'></script>
        <script type="text/javascript" charset="utf-8" src='../resources/webjars/2.3.0-RC1/prettify/lang-scala.js'></script>
        <script type="text/javascript">
            $(function() {
                window.prettyPrint && prettyPrint();
            });
        </script>

    </body>
</html>

<!-- Localized -->