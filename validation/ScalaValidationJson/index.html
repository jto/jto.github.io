

<html>
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
        <title>ScalaValidationJson</title>
        <link rel="stylesheet" media="screen" href="../resources/style/main.css"></link>
        <script type="text/javascript" src='../resources/webjars/2.3.0-RC1/jquery/jquery.min.js'></script>
        <script type="text/javascript" src="../resources/style/main.js"></script>
    </head>
    <body>

        <section id="top">
            <div class="wrapper">
                <h1><a href="../index.html">Manual, tutorials & references</a></h1>
                <nav>
                    <span class="versions">
                        <span>Browse APIs</span>
                        <select onchange="document.location=this.value">
                            <option selected disabled>Select language</option>
                            <option value="/@documentation/api/scala/index.html">Scala</option>
                            <option value="/@documentation/api/java/index.html">Java</option>
                        </select>
                    </span>
                </nav>
            </div>
        </section>

        <div id="content" class="wrapper doc">
            <article id="main">
                
                    <h2>Validating Json</h2><p>Take this JSON example:</p>
<pre class="prettyprint"><code class="language-json">{
  &quot;user&quot;: {
    &quot;name&quot; : &quot;toto&quot;,
    &quot;age&quot; : 25,
    &quot;email&quot; : &quot;toto@jmail.com&quot;,
    &quot;isAlive&quot; : true,
    &quot;friend&quot; : {
  	  &quot;name&quot; : &quot;tata&quot;,
  	  &quot;age&quot; : 20,
  	  &quot;email&quot; : &quot;tata@coldmail.com&quot;
    }
  }
}
</code></pre><p>This can be seen as a tree structure using the 2 following structures:</p>
<ul>
  <li><strong>JSON object</strong> contains a set of <code>name</code> / <code>value</code> pairs:
  <ul>
    <li><code>name</code> is a String</li>
    <li><code>value</code> can be :
    <ul>
      <li>string</li>
      <li>number</li>
      <li>another JSON object</li>
      <li>a JSON array</li>
      <li>true/false</li>
      <li>null</li>
    </ul></li>
  </ul></li>
  <li><strong>JSON array</strong> is a sequence of values from the previously listed value types.</li>
</ul>
<blockquote><p>If you want to have more info about the exact JSON standard, please go to <a href="http://json.org/">json.org</a></p>
</blockquote><h2>Json Data Types</h2><p><code>play.api.libs.json</code> package contains 7 JSON data types reflecting exactly the previous structure.<br/>All types inherit from the generic JSON trait, <code>JsValue</code>. As Stated in <a href=" ../ScalaJson/index.html">the Json API documentation </a>, we can easily parse this String into a JsValue:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.libs.json._

val json: JsValue = Json.parse(&quot;&quot;&quot;
{
  &quot;user&quot;: {
    &quot;name&quot; : &quot;toto&quot;,
    &quot;age&quot; : 25,
    &quot;email&quot; : &quot;toto@jmail.com&quot;,
    &quot;isAlive&quot; : true,
    &quot;friend&quot; : {
      &quot;name&quot; : &quot;tata&quot;,
      &quot;age&quot; : 20,
      &quot;email&quot; : &quot;tata@coldmail.com&quot;
    }
  }
}
&quot;&quot;&quot;)</code></pre><p>This sample is used in all next samples.<br/>The Validation API will work on the JsValue.</p><h2>Accessing Path in a JSON tree</h2><p>The validation API defines a class named <code>Path</code>. A <code>Path</code> represents a location. Contrarely to <code>JsPath</code>, it&rsquo;s not related to any specific type, it&rsquo;s just a location in some data. Most of the time, a <code>Path</code> is our entry point into the Validation API.</p><h3>Navigating in data using <code>Path</code></h3>
<pre class="prettyprint"><code class="language-scala">import play.api.data.mapping._
val location: Path = Path \ &quot;user&quot; \ &quot;friend&quot;</code></pre><p><code>Path</code> has a <code>read</code> method. Just as in the Json API, read will build a <code>Rule</code> looking for data of the given type, at that location.<br/><code>read</code> is a paramaterized method it takes two types parameter, <code>I</code> and <code>O</code>. <code>I</code> represent the input we&rsquo;re trying to parse, and <code>O</code> is the output type.</p><p>For example, <code>(Path \ &quot;foo&quot;).read[JsValue, Int]</code>, means the we want to parse a value located at path <code>foo</code>, in a JsValue, and parse it as an <code>Int</code>.</p><p>But let&rsquo;s try something much much easier for now:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.data.mapping._
val findFriend: Rule[JsValue, JsValue] = location.read[JsValue, JsValue]                                                             ^
</code></pre><p><code>location.read[JsValue, JsValue]</code> means the we&rsquo;re trying lookup at <code>location</code> in a <code>JsValue</code>, and we expect to find a <code>JsValue</code> there. Effectivelly, we&rsquo;re just defining a <code>Rule</code> that is picking a subtree in a Json.</p><p>If you try to run that code, the compiler gives you the following error:</p>
<pre class="prettyprint"><code>error: No implicit view available from play.api.data.mapping.Path =&gt; play.api.data.mapping.Rule[play.api.libs.json.JsValue,play.api.libs.json.JsValue].
       val findFriend: Rule[JsValue, JsValue] = location.read[JsValue, JsValue]
</code></pre><p>The scala compiler is complaining about not finding an implicit Function of type Path =&gt; Rule[JsValue, JsValue]. Indeed, unlike the Json API, you have to provide a method to &ldquo;lookup&rdquo; into the data you expect to validate. Fortunatelly, such method already exists and is provided for Json. All you have to do is import it:</p>
<pre class="prettyprint"><code class="language-scala">import play.api.data.mapping.json.Rules._</code></pre><p>By convention, all usefull validation methods for a given type are to be found in an object called <code>Rules</code>. That object contains a bunch of implicits defining how to lookup in the data, and how to coerce some of the possible values of those data into Scala types.</p><p>With those implicits in scope, we can finally create our <code>Rule</code>.</p>
<pre class="prettyprint"><code class="language-scala">import play.api.data.mapping.json.Rules._
val findFriend: Rule[JsValue, JsValue] = location.read[JsValue, JsValue]</code></pre><p>Alright, so far we&rsquo;ve defined a <code>Rule</code> looking for some data of type JsValue, in an object of type JsValue, at <code>/user/friend</code>.<br/>Now we need to apply this <code>Rule</code> to our data.</p>
<pre class="prettyprint"><code class="language-scala">findFriend.validate(json) === Success(Json.parse(&quot;&quot;&quot;{&quot;name&quot;:&quot;tata&quot;,&quot;age&quot;:20,&quot;email&quot;:&quot;tata@coldmail.com&quot;}&quot;&quot;&quot;))</code></pre><p>When we apply a <code>Rule</code>, we have no guarantee whatsoever that it&rsquo;s going to succeed. There&rsquo;s various things that could fail, so instead of just returning some data of type <code>O</code>, <code>validate</code> returns an instance of <code>Validation</code>.<br/>A <code>Validation</code> can only have two types: It&rsquo;s either a <code>Success</code> containing the result we expect, or a <code>Failure</code> containing all the errors along with their locations.</p><p>Let&rsquo;s try something that we know will fail: We&rsquo;ll try to lookup for a JsValue at a non existing location:</p>
<pre class="prettyprint"><code class="language-scala">(Path \ &quot;somenonexistinglocation&quot;).read[JsValue, JsValue].validate(json) === Failure(Seq((Path \ &quot;somenonexistinglocation&quot;, Seq(ValidationError(&quot;error.required&quot;)))))</code></pre><p>This time <code>validate</code> returns <code>Failure</code>. There&rsquo;s nothing at <code>somenonexistinglocation</code> and this failure tells us just that. We required a <code>JsValue</code> to be found at that Path, but our requirement was not fullfiled. Note that the <code>Failure</code> does not just contain a <code>Path</code> and an error message. It contains a <code>List[(Path, List[ValidationError])]</code>. We&rsquo;ll see later that a single validation could find several errors at a given <code>Path</code>, AND find errors at different <code>Path</code></p>
                
            </article>
            <aside>
                <h3>Play data validation API</h3>
<ul>
  <li><a href=" ../ScalaValidation/index.html">Introduction </a></li>
  <li><a href=" ../ScalaValidationRule/index.html">Validation and transformation with Rule </a></li>
  <li><a href=" ../ScalaValidationRuleCombinators/index.html">Complex validation: combining Rules </a></li>
  <li><a href=" ../ScalaValidationWrite/index.html">Serialization with Write </a></li>
  <li><a href=" ../ScalaValidationWriteCombinators/index.html">Complex serialization: combining Writes </a></li>
  <li><a href=" ../ScalaValidationForm/index.html">Forms template helpers </a></li>
  <li><a href=" ../ScalaValidationMacros/index.html">Validation Inception </a></li>
  <li><a href=" ../ScalaValidationExtensions/index.html">Supporting new types </a></li>
  <li><a href=" ../ScalaValidationMigrationJson/index.html">Migration from 2.1.x Json API </a></li>
  <li><a href=" ../ScalaValidationMigrationForm/index.html">Migration from 2.1.x Form API </a></li>
  <li><a href=" ../ScalaValidationCookbook/index.html">Cookbook </a></li>
</ul><h3>Main concepts</h3>
<ul>
  <li><a href=" ../ScalaActions/index.html">HTTP programming </a></li>
  <li><a href=" ../ScalaAsync/index.html">Asynchronous HTTP programming </a></li>
  <li><a href=" ../ScalaTemplates/index.html">The template engine </a></li>
  <li><a href=" ../ScalaForms/index.html">HTTP form submission and validation </a></li>
  <li><a href=" ../ScalaJson/index.html">Working with JSON </a></li>
  <li><a href=" ../ScalaXmlRequests/index.html">Working with XML </a></li>
  <li><a href=" ../ScalaFileUpload/index.html">Handling file upload </a></li>
  <li><a href=" ../ScalaDatabase/index.html">Accessing an SQL database </a></li>
  <li><a href=" ../ScalaCache/index.html">Using the Cache </a></li>
  <li><a href=" ../ScalaWS/index.html">Calling WebServices </a></li>
  <li><a href=" ../ScalaAkka/index.html">Integrating with Akka </a></li>
  <li><a href=" ../ScalaI18N/index.html">Internationalization </a></li>
  <li><a href=" ../ScalaGlobal/index.html">The application Global object </a></li>
  <li><a href=" ../ScalaTest/index.html">Testing your application </a></li>
</ul><h3>Advanced topics</h3>
<ul>
  <li><a href=" ../Iteratees/index.html">Handling data streams reactively </a></li>
</ul><h3>Tutorials</h3>
<ul>
  <li><a href=" ../ScalaTodoList/index.html">Your first application </a></li>
</ul>
            </aside>
        </div>

        <style type="text/css">
            @import '../resources/webjars/2.3.0-RC1/prettify/prettify.css';
        </style>
        <script type="text/javascript" charset="utf-8" src='../resources/webjars/2.3.0-RC1/prettify/prettify.js'></script>
        <script type="text/javascript" charset="utf-8" src='../resources/webjars/2.3.0-RC1/prettify/lang-scala.js'></script>
        <script type="text/javascript">
            $(function() {
                window.prettyPrint && prettyPrint();
            });
        </script>

    </body>
</html>

<!-- Localized -->